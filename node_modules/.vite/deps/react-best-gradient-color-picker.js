import {
  html2canvas_esm_default
} from "./chunk-KGD2QFCX.js";
import {
  require_react_dom
} from "./chunk-X3B7SAOS.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/tinycolor2/tinycolor.js
var require_tinycolor = __commonJS({
  "node_modules/tinycolor2/tinycolor.js"(exports, module) {
    (function(Math2) {
      var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
      function tinycolor7(color, opts) {
        color = color ? color : "";
        opts = opts || {};
        if (color instanceof tinycolor7) {
          return color;
        }
        if (!(this instanceof tinycolor7)) {
          return new tinycolor7(color, opts);
        }
        var rgb = inputToRGB(color);
        this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;
        if (this._r < 1) {
          this._r = mathRound(this._r);
        }
        if (this._g < 1) {
          this._g = mathRound(this._g);
        }
        if (this._b < 1) {
          this._b = mathRound(this._b);
        }
        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
      }
      tinycolor7.prototype = {
        isDark: function() {
          return this.getBrightness() < 128;
        },
        isLight: function() {
          return !this.isDark();
        },
        isValid: function() {
          return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
          return this._format;
        },
        getAlpha: function() {
          return this._a;
        },
        getBrightness: function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        },
        getLuminance: function() {
          var rgb = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R, G, B;
          RsRGB = rgb.r / 255;
          GsRGB = rgb.g / 255;
          BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R = RsRGB / 12.92;
          } else {
            R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G = GsRGB / 12.92;
          } else {
            G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B = BsRGB / 12.92;
          } else {
            B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        },
        setAlpha: function(value) {
          this._a = boundAlpha(value);
          this._roundA = mathRound(100 * this._a) / 100;
          return this;
        },
        toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
          return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function() {
          return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
          return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
          if (this._a === 0) {
            return "transparent";
          }
          if (this._a < 1) {
            return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s = tinycolor7(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function(format) {
          var formatSet = !!format;
          format = format || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
          if (needsAlphaFormat) {
            if (format === "name" && this._a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
          }
          if (format === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format === "name") {
            formattedString = this.toName();
          }
          if (format === "hsl") {
            formattedString = this.toHslString();
          }
          if (format === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        },
        clone: function() {
          return tinycolor7(this.toString());
        },
        _applyModification: function(fn, args) {
          var color = fn.apply(null, [this].concat([].slice.call(args)));
          this._r = color._r;
          this._g = color._g;
          this._b = color._b;
          this.setAlpha(color._a);
          return this;
        },
        lighten: function() {
          return this._applyModification(lighten, arguments);
        },
        brighten: function() {
          return this._applyModification(brighten, arguments);
        },
        darken: function() {
          return this._applyModification(darken, arguments);
        },
        desaturate: function() {
          return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
          return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
          return this._applyModification(greyscale, arguments);
        },
        spin: function() {
          return this._applyModification(spin, arguments);
        },
        _applyCombination: function(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
          return this._applyCombination(analogous, arguments);
        },
        complement: function() {
          return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
          return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
          return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
          return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
          return this._applyCombination(tetrad, arguments);
        }
      };
      tinycolor7.fromRatio = function(color, opts) {
        if (typeof color == "object") {
          var newColor = {};
          for (var i in color) {
            if (color.hasOwnProperty(i)) {
              if (i === "a") {
                newColor[i] = color[i];
              } else {
                newColor[i] = convertToPercentage(color[i]);
              }
            }
          }
          color = newColor;
        }
        return tinycolor7(color, opts);
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;
        if (typeof color == "string") {
          color = stringInputToObject(color);
        }
        if (typeof color == "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
          }
          if (color.hasOwnProperty("a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format,
          r: mathMin(255, mathMax(rgb.r, 0)),
          g: mathMin(255, mathMax(rgb.g, 0)),
          b: mathMin(255, mathMax(rgb.b, 0)),
          a
        };
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;
        if (max == min) {
          h = s = 0;
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, l };
      }
      function hslToRgb(h, s, l) {
        var r, g, b;
        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        function hue2rgb(p2, q2, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 2 / 3)
            return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        }
        if (s === 0) {
          r = g = b = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;
        var d = max - min;
        s = max === 0 ? 0 : d / max;
        if (max == min) {
          h = 0;
        } else {
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, v };
      }
      function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
        ];
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToArgbHex(r, g, b, a) {
        var hex = [
          pad2(convertDecimalToHex(a)),
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
        ];
        return hex.join("");
      }
      tinycolor7.equals = function(color1, color2) {
        if (!color1 || !color2) {
          return false;
        }
        return tinycolor7(color1).toRgbString() == tinycolor7(color2).toRgbString();
      };
      tinycolor7.random = function() {
        return tinycolor7.fromRatio({
          r: mathRandom(),
          g: mathRandom(),
          b: mathRandom()
        });
      };
      function desaturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor7(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor7(hsl);
      }
      function saturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor7(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor7(hsl);
      }
      function greyscale(color) {
        return tinycolor7(color).desaturate(100);
      }
      function lighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor7(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor7(hsl);
      }
      function brighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb = tinycolor7(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
        return tinycolor7(rgb);
      }
      function darken(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor7(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor7(hsl);
      }
      function spin(color, amount) {
        var hsl = tinycolor7(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor7(hsl);
      }
      function complement(color) {
        var hsl = tinycolor7(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor7(hsl);
      }
      function triad(color) {
        var hsl = tinycolor7(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor7(color),
          tinycolor7({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
          tinycolor7({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function tetrad(color) {
        var hsl = tinycolor7(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor7(color),
          tinycolor7({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
          tinycolor7({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
          tinycolor7({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function splitcomplement(color) {
        var hsl = tinycolor7(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor7(color),
          tinycolor7({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
          tinycolor7({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl = tinycolor7(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor7(color)];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(tinycolor7(hsl));
        }
        return ret;
      }
      function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor7(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
          ret.push(tinycolor7({ h, s, v }));
          v = (v + modification) % 1;
        }
        return ret;
      }
      tinycolor7.mix = function(color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor7(color1).toRgb();
        var rgb2 = tinycolor7(color2).toRgb();
        var p = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return tinycolor7(rgba);
      };
      tinycolor7.readability = function(color1, color2) {
        var c1 = tinycolor7(color1);
        var c2 = tinycolor7(color2);
        return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      };
      tinycolor7.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor7.readability(color1, color2);
        var wcag2Parms, out;
        out = false;
        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      };
      tinycolor7.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size = args.size;
        for (var i = 0; i < colorList.length; i++) {
          readability = tinycolor7.readability(baseColor, colorList[i]);
          if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor7(colorList[i]);
          }
        }
        if (tinycolor7.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
          return bestColor;
        } else {
          args.includeFallbackColors = false;
          return tinycolor7.mostReadable(baseColor, ["#fff", "#000"], args);
        }
      };
      var names = tinycolor7.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      };
      var hexNames = tinycolor7.hexNames = flip(names);
      function flip(o) {
        var flipped = {};
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
          }
        }
        return flipped;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function bound01(n, max) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));
        if (processPercent) {
          n = parseInt(n * max, 10) / 100;
        }
        if (Math2.abs(n - max) < 1e-6) {
          return 1;
        }
        return n % max / parseFloat(max);
      }
      function clamp01(val) {
        return mathMin(1, mathMax(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") != -1;
      }
      function pad2(c) {
        return c.length == 1 ? "0" + c : "" + c;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          n = n * 100 + "%";
        }
        return n;
      }
      function convertDecimalToHex(d) {
        return Math2.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?";
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
      }
      function stringInputToObject(color) {
        color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color == "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match;
        if (match = matchers.rgb.exec(color)) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        if (match = matchers.rgba.exec(color)) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if (match = matchers.hsl.exec(color)) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        if (match = matchers.hsla.exec(color)) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if (match = matchers.hsv.exec(color)) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        if (match = matchers.hsva.exec(color)) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if (match = matchers.hex8.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex6.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        if (match = matchers.hex4.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            a: convertHexToDecimal(match[4] + "" + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex3.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function validateWCAG2Parms(parms) {
        var level, size;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
          level = "AA";
        }
        if (size !== "small" && size !== "large") {
          size = "small";
        }
        return { "level": level, "size": size };
      }
      if (typeof module !== "undefined" && module.exports) {
        module.exports = tinycolor7;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return tinycolor7;
        });
      } else {
        window.tinycolor = tinycolor7;
      }
    })(Math);
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString2 = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle2;
  }
});

// node_modules/react-best-gradient-color-picker/dist/esm/components/index.js
var import_react18 = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/context.js
var import_react = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/constants.js
var config = {
  barSize: 18,
  crossSize: 18,
  inputSize: 40,
  delay: 150,
  defaultColor: "rgba(175, 51, 242, 1)",
  defaultGradient: "linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%)"
};
var defaultLocales = {
  CONTROLS: {
    SOLID: "Solid",
    GRADIENT: "Gradient"
  }
};
var fakePresets = [
  "rgba(0,0,0,1)",
  "rgba(128,128,128, 1)",
  "rgba(192,192,192, 1)",
  "rgba(255,255,255, 1)",
  "rgba(0,0,128,1)",
  "rgba(0,0,255,1)",
  "rgba(0,255,255, 1)",
  "rgba(0,128,0,1)",
  "rgba(128,128,0, 1)",
  "rgba(0,128,128,1)",
  "rgba(0,255,0, 1)",
  "rgba(128,0,0, 1)",
  "rgba(128,0,128, 1)",
  "rgba(175, 51, 242, 1)",
  "rgba(255,0,255, 1)",
  "rgba(255,0,0, 1)",
  "rgba(240, 103, 46, 1)",
  "rgba(255,255,0, 1)"
];

// node_modules/react-best-gradient-color-picker/dist/esm/utils/gradientParser.js
var import_tinycolor2 = __toESM(require_tinycolor(), 1);
var gradientParser = (input = "") => {
  const tokens = {
    linearGradient: /^(-(webkit|o|ms|moz)-)?(linear-gradient)/i,
    repeatingLinearGradient: /^(-(webkit|o|ms|moz)-)?(repeating-linear-gradient)/i,
    radialGradient: /^(-(webkit|o|ms|moz)-)?(radial-gradient)/i,
    repeatingRadialGradient: /^(-(webkit|o|ms|moz)-)?(repeating-radial-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    spacedRgbColor: /^(\d{1,3})\s+(\d{1,3})\s+(\d{1,3})\s+\/\s+([0-1](\.\d+)?)/,
    rgbaColor: /^rgba/i,
    hslColor: /^hsl/i,
    hsvColor: /^hsv/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  function error(msg) {
    const err = new Error(input + ": " + msg);
    throw err;
  }
  function consume(size) {
    input = input.substr(size);
  }
  function scan(regexp) {
    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    const captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function matchListing(matcher) {
    let captures = matcher();
    const result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error("One extra comma");
        }
      }
    }
    return result;
  }
  function match(type, pattern, captureIndex) {
    const captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function matchHexColor() {
    const hexObj = match("hex", tokens.hexColor, 1);
    if (hexObj == null ? void 0 : hexObj.value) {
      const { r, g, b, a } = (0, import_tinycolor2.default)(hexObj == null ? void 0 : hexObj.value).toRgb();
      return {
        value: `rgba(${r}, ${g}, ${b}, ${a})`
      };
    }
  }
  const checkCaps = (val) => {
    const capIt = isUpperCase(val == null ? void 0 : val[0]);
    return {
      value: `${capIt ? "RGBA" : "rgba"}(${matchListing(matchNumber)})`
    };
  };
  function matchCall(pattern, callback) {
    const captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error("Missing (");
      }
      const result = callback(captures);
      if (!scan(tokens.endCall)) {
        error("Missing )");
      }
      return result;
    }
  }
  function matchHSLColor() {
    return matchCall(tokens.hslColor, convertHsl);
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, checkCaps);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, convertRgb);
  }
  function matchLiteralColor() {
    const litObj = match("literal", tokens.literalColor, 0);
    if (litObj == null ? void 0 : litObj.value) {
      const { r, g, b, a } = (0, import_tinycolor2.default)(litObj == null ? void 0 : litObj.value).toRgb();
      return {
        value: `rgba(${r}, ${g}, ${b}, ${a})`
      };
    }
  }
  function matchHSVColor() {
    return matchCall(tokens.hsvColor, convertHsv);
  }
  function matchColor() {
    return matchHexColor() || matchHSLColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor() || matchHSVColor();
  }
  function matchColorStop() {
    var _a;
    const color = matchColor();
    if (!color) {
      error("Expected color definition");
    }
    color.left = parseInt((_a = matchDistance()) == null ? void 0 : _a.value);
    return color;
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function() {
      const orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens.repeatingRadialGradient, matchListRadialOrientations);
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function getAST() {
    var _a;
    const ast = matchListDefinitions();
    if (input.length > 0) {
      error("Invalid input not EOF");
    }
    const ast0 = ast[0];
    const checkSelected = (_a = ast0 == null ? void 0 : ast0.colorStops) == null ? void 0 : _a.filter((c) => isUpperCase(c.value)).length;
    const getGradientObj = () => {
      if (checkSelected > 0) {
        return ast0;
      } else {
        const val = (c, i) => i === 0 ? high(c) : low(c);
        return {
          ...ast0,
          colorStops: ast0.colorStops.map((c, i) => ({
            ...c,
            value: val(c, i)
          }))
        };
      }
    };
    return getGradientObj();
  }
  function matchSideOrCorner() {
    return match("directional", tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    let radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      const extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        const positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        const defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-expect-error - need to circle back for these types
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function matchCircle() {
    const circle = match("shape", /^(circle)/i, 0);
    if (circle) {
      circle.style = matchLength() || matchExtentKeyword();
    }
    return circle;
  }
  function matchEllipse() {
    const ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      const positioning = matchPositioning();
      if (!positioning) {
        error("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    const location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  const convertHsl = (val) => {
    const capIt = isUpperCase(val == null ? void 0 : val[0]);
    const hsl = matchListing(matchNumber);
    const { r, g, b, a } = (0, import_tinycolor2.default)({
      h: hsl[0],
      s: hsl[1],
      l: hsl[2],
      a: hsl[3] || 1
    }).toRgb();
    return {
      value: `${capIt ? "RGBA" : "rgba"}(${r}, ${g}, ${b}, ${a})`
    };
  };
  const convertHsv = (val) => {
    const capIt = isUpperCase(val == null ? void 0 : val[0]);
    const hsv = matchListing(matchNumber);
    const { r, g, b, a } = (0, import_tinycolor2.default)({
      h: hsv[0],
      s: hsv[1],
      v: hsv[2],
      a: hsv[3] || 1
    }).toRgb();
    return {
      value: `${capIt ? "RGBA" : "rgba"}(${r}, ${g}, ${b}, ${a})`
    };
  };
  const convertRgb = (val) => {
    const capIt = isUpperCase(val == null ? void 0 : val[0]);
    const captures = scan(tokens.spacedRgbColor);
    const [, r, g, b, a = 1] = captures || [null, ...matchListing(matchNumber)];
    return {
      value: `${capIt ? "RGBA" : "rgba"}(${r}, ${g}, ${b}, ${a})`
    };
  };
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens.positionKeywords, 1);
  }
  return getAST();
};

// node_modules/react-best-gradient-color-picker/dist/esm/utils/formatters.js
var { defaultColor, defaultGradient } = config;
var low = (color) => {
  return color.value.toLowerCase();
};
var high = (color) => {
  return color.value.toUpperCase();
};
var getColors = (value) => {
  const isGradient = value == null ? void 0 : value.includes("gradient");
  if (isGradient) {
    const isConic = value == null ? void 0 : value.includes("conic");
    const safeValue = !isConic ? value : defaultGradient;
    if (isConic) {
      console.log("Sorry we cant handle conic gradients yet");
    }
    const obj = gradientParser(safeValue);
    return obj == null ? void 0 : obj.colorStops;
  } else {
    const safeValue = value || defaultColor;
    return [{ value: safeValue }];
  }
};
var formatInputValues = (value, min, max) => {
  return isNaN(value) ? min : value < min ? min : value > max ? max : value;
};
var round = (val) => {
  return Math.round(val);
};

// node_modules/react-best-gradient-color-picker/dist/esm/utils/utils.js
var { barSize, crossSize } = config;
var safeBounds = (e) => {
  const client = e.target.parentNode.getBoundingClientRect();
  const className = e.target.className;
  const adjuster = className === "c-resize ps-rl" ? 15 : 0;
  return {
    offsetLeft: (client == null ? void 0 : client.x) + adjuster,
    offsetTop: client == null ? void 0 : client.y,
    clientWidth: client == null ? void 0 : client.width,
    clientHeight: client == null ? void 0 : client.height
  };
};
function getHandleValue(e) {
  const { offsetLeft, clientWidth } = safeBounds(e);
  const pos = e.clientX - offsetLeft - barSize / 2;
  const adjuster = clientWidth - 18;
  const bounded = formatInputValues(pos, 0, adjuster);
  return Math.round(bounded / (adjuster / 100));
}
function computeSquareXY(s, v, squareWidth, squareHeight) {
  const x = s * squareWidth - crossSize / 2;
  const y = (100 - v) / 100 * squareHeight - crossSize / 2;
  return [x, y];
}
var getClientXY = (e) => {
  if (e.clientX) {
    return { clientX: e.clientX, clientY: e.clientY };
  } else {
    const touch = e.touches[0] || {};
    return { clientX: touch.clientX, clientY: touch.clientY };
  }
};
function computePickerPosition(e) {
  const { offsetLeft, offsetTop, clientWidth, clientHeight } = safeBounds(e);
  const { clientX, clientY } = getClientXY(e);
  const getX = () => {
    const xPos = clientX - offsetLeft - crossSize / 2;
    return formatInputValues(xPos, -9, clientWidth - 10);
  };
  const getY = () => {
    const yPos = clientY - offsetTop - crossSize / 2;
    return formatInputValues(yPos, -9, clientHeight - 10);
  };
  return [getX(), getY()];
}
var isUpperCase = (str) => {
  var _a;
  return (str == null ? void 0 : str[0]) === ((_a = str == null ? void 0 : str[0]) == null ? void 0 : _a.toUpperCase());
};
var convertShortHandDeg = (dir) => {
  if (dir === "to top") {
    return 0;
  } else if (dir === "to bottom") {
    return 180;
  } else if (dir === "to left") {
    return 270;
  } else if (dir === "to right") {
    return 90;
  } else if (dir === "to top right") {
    return 45;
  } else if (dir === "to bottom right") {
    return 135;
  } else if (dir === "to bottom left") {
    return 225;
  } else if (dir === "to top left") {
    return 315;
  } else {
    const safeDir = dir || 0;
    return parseInt(safeDir);
  }
};
var objectToString = (value) => {
  var _a, _b, _c, _d, _e;
  if (typeof value === "string") {
    return value;
  } else {
    if ((_a = value == null ? void 0 : value.type) == null ? void 0 : _a.includes("gradient")) {
      const sorted = (_b = value == null ? void 0 : value.colorStops) == null ? void 0 : _b.sort((a, b) => (a == null ? void 0 : a.left) - (b == null ? void 0 : b.left));
      const string = (_c = sorted == null ? void 0 : sorted.map((c) => `${c == null ? void 0 : c.value} ${c == null ? void 0 : c.left}%`)) == null ? void 0 : _c.join(", ");
      const type = value == null ? void 0 : value.type;
      const degs = convertShortHandDeg((_d = value == null ? void 0 : value.orientation) == null ? void 0 : _d.value);
      const gradientStr = type === "linear-gradient" ? `${degs}deg` : "circle";
      return `${type}(${gradientStr}, ${string})`;
    } else {
      const color = ((_e = value == null ? void 0 : value.colorStops[0]) == null ? void 0 : _e.value) || "rgba(175, 51, 242, 1)";
      return color;
    }
  }
};
var getColorObj = (colors) => {
  var _a;
  const idxCols = colors == null ? void 0 : colors.map((c, i) => ({
    ...c,
    index: i
  }));
  const upperObj = idxCols == null ? void 0 : idxCols.find((c) => isUpperCase(c.value));
  const ccObj = upperObj || idxCols[0];
  return {
    currentColor: (ccObj == null ? void 0 : ccObj.value) || ((_a = config) == null ? void 0 : _a.defaultGradient),
    selectedColor: (ccObj == null ? void 0 : ccObj.index) || 0,
    currentLeft: (ccObj == null ? void 0 : ccObj.left) || 0
  };
};
var getDegrees = (value) => {
  var _a;
  const s1 = value == null ? void 0 : value.split(",")[0];
  const s2 = (_a = s1 == null ? void 0 : s1.split("(")[1]) == null ? void 0 : _a.replace("deg", "");
  return convertShortHandDeg(s2);
};
var getDetails = (value) => {
  const isGradient = value == null ? void 0 : value.includes("gradient");
  const gradientType = value == null ? void 0 : value.split("(")[0];
  const degrees = getDegrees(value);
  const degreeStr = gradientType === "linear-gradient" ? `${degrees}deg` : "circle";
  return {
    degrees,
    degreeStr,
    isGradient,
    gradientType
  };
};

// node_modules/react-best-gradient-color-picker/dist/esm/context.js
var import_tinycolor22 = __toESM(require_tinycolor(), 1);
var PickerContext = (0, import_react.createContext)(null);
function PickerContextWrapper({ value, classes, children, onChange, squareWidth, hideOpacity, squareHeight }) {
  const colors = getColors(value);
  const { degrees, degreeStr, isGradient, gradientType } = getDetails(value);
  const { currentColor, selectedColor, currentLeft } = getColorObj(colors);
  const [inputType, setInputType] = (0, import_react.useState)("rgb");
  const [previous, setPrevious] = (0, import_react.useState)({});
  const tinyColor = (0, import_tinycolor22.default)(currentColor);
  const rgba = tinyColor.toRgb();
  const hsv = tinyColor.toHsv();
  const [hc, setHc] = (0, import_react.useState)({ ...rgba, ...hsv });
  (0, import_react.useEffect)(() => {
    if ((hsv == null ? void 0 : hsv.s) === 0) {
      setHc({ ...rgba, ...hsv, h: hc == null ? void 0 : hc.h });
    } else {
      setHc({ ...rgba, ...hsv });
    }
  }, [currentColor]);
  const createGradientStr = (newColors) => {
    const sorted = newColors.sort((a, b) => a.left - b.left);
    const colorString = sorted == null ? void 0 : sorted.map((cc) => `${cc == null ? void 0 : cc.value} ${cc.left}%`);
    const newGrade = `${gradientType}(${degreeStr}, ${colorString.join(", ")})`;
    setPrevious({ ...previous, gradient: newGrade });
    onChange(newGrade);
  };
  const handleGradient = (newColor, left) => {
    const remaining = colors == null ? void 0 : colors.filter((c) => !isUpperCase(c.value));
    const newColors = [
      { value: newColor.toUpperCase(), left: left || currentLeft },
      ...remaining
    ];
    createGradientStr(newColors);
  };
  const handleChange = (newColor) => {
    if (isGradient) {
      handleGradient(newColor);
    } else {
      setPrevious({ ...previous, color: newColor });
      onChange(newColor);
    }
  };
  const deletePoint = () => {
    if ((colors == null ? void 0 : colors.length) > 2) {
      const formatted = colors == null ? void 0 : colors.map((fc, i) => ({
        ...fc,
        value: i === selectedColor - 1 ? high(fc) : low(fc)
      }));
      const remaining = formatted == null ? void 0 : formatted.filter((_, i) => i !== selectedColor);
      createGradientStr(remaining);
    }
  };
  const pickerContext = {
    hc,
    setHc,
    value,
    colors,
    degrees,
    classes,
    onChange,
    previous,
    inputType,
    tinyColor,
    isGradient,
    squareWidth,
    hideOpacity,
    currentLeft,
    deletePoint,
    squareHeight,
    setInputType,
    gradientType,
    handleChange,
    currentColor,
    selectedColor,
    handleGradient,
    createGradientStr
  };
  return import_react.default.createElement(PickerContext.Provider, { value: pickerContext }, children);
}
function usePicker() {
  const pickerContext = (0, import_react.useContext)(PickerContext);
  if (!pickerContext) {
    throw new Error("usePicker has to be used within <PickerContext.Provider>");
  }
  return pickerContext;
}

// node_modules/react-best-gradient-color-picker/dist/esm/components/Picker.js
var import_react17 = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/components/Hue.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/hooks/usePaintHue.js
var import_react2 = __toESM(require_react(), 1);
var import_tinycolor23 = __toESM(require_tinycolor(), 1);
var usePaintHue = (canvas, squareWidth) => {
  (0, import_react2.useEffect)(() => {
    var _a;
    const ctx = (_a = canvas == null ? void 0 : canvas.current) == null ? void 0 : _a.getContext("2d", { willReadFrequently: true });
    if (ctx) {
      ctx.rect(0, 0, squareWidth, 14);
      const gradient = ctx.createLinearGradient(0, 0, squareWidth, 0);
      for (let i = 0; i <= 360; i += 30) {
        gradient.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`);
      }
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }, [canvas, squareWidth]);
};
var usePaintHue_default = usePaintHue;
var usePaintSat = (canvas, h, l, squareWidth) => {
  (0, import_react2.useEffect)(() => {
    var _a;
    const ctx = (_a = canvas == null ? void 0 : canvas.current) == null ? void 0 : _a.getContext("2d", { willReadFrequently: true });
    if (ctx) {
      ctx.rect(0, 0, squareWidth, 14);
      const gradient = ctx.createLinearGradient(0, 0, squareWidth, 0);
      for (let i = 0; i <= 100; i += 10) {
        gradient.addColorStop(i / 100, `hsl(${h}, ${i}%, ${l}%)`);
      }
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }, [canvas, h, l, squareWidth]);
};
var usePaintLight = (canvas, h, s, squareWidth) => {
  (0, import_react2.useEffect)(() => {
    var _a;
    const ctx = (_a = canvas == null ? void 0 : canvas.current) == null ? void 0 : _a.getContext("2d", { willReadFrequently: true });
    if (ctx) {
      ctx.rect(0, 0, squareWidth, 14);
      const gradient = ctx.createLinearGradient(0, 0, squareWidth, 0);
      for (let i = 0; i <= 100; i += 10) {
        gradient.addColorStop(i / 100, `hsl(${h}, ${s}%, ${i}%)`);
      }
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }, [canvas, h, s, squareWidth]);
};
var usePaintBright = (canvas, h, s, squareWidth) => {
  (0, import_react2.useEffect)(() => {
    var _a;
    const ctx = (_a = canvas == null ? void 0 : canvas.current) == null ? void 0 : _a.getContext("2d", { willReadFrequently: true });
    if (ctx) {
      ctx.rect(0, 0, squareWidth, 14);
      const gradient = ctx.createLinearGradient(0, 0, squareWidth, 0);
      for (let i = 0; i <= 100; i += 10) {
        const hsl = (0, import_tinycolor23.default)({ h, s, v: i });
        gradient.addColorStop(i / 100, hsl.toHslString());
      }
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }, [canvas, h, s, squareWidth]);
};

// node_modules/react-best-gradient-color-picker/dist/esm/components/Hue.js
var import_tinycolor24 = __toESM(require_tinycolor(), 1);
var Hue = () => {
  const barRef = (0, import_react3.useRef)(null);
  const { handleChange, squareWidth, hc, setHc } = usePicker();
  const [dragging, setDragging] = (0, import_react3.useState)(false);
  usePaintHue_default(barRef, squareWidth);
  const stopDragging = () => {
    setDragging(false);
  };
  const handleDown = () => {
    setDragging(true);
  };
  const handleHue = (e) => {
    const newHue = getHandleValue(e) * 3.6;
    const tinyHsv = (0, import_tinycolor24.default)({ h: newHue, s: hc == null ? void 0 : hc.s, v: hc == null ? void 0 : hc.v });
    const { r, g, b } = tinyHsv.toRgb();
    handleChange(`rgba(${r}, ${g}, ${b}, ${hc.a})`);
    setHc({ ...hc, h: newHue });
  };
  const handleMove = (e) => {
    if (dragging) {
      handleHue(e);
    }
  };
  const handleClick = (e) => {
    if (!dragging) {
      handleHue(e);
    }
  };
  (0, import_react3.useEffect)(() => {
    const handleUp = () => {
      stopDragging();
    };
    window.addEventListener("mouseup", handleUp);
    return () => {
      window.removeEventListener("mouseup", handleUp);
    };
  }, []);
  return import_react3.default.createElement(
    "div",
    { style: {
      height: 14,
      marginTop: 17,
      marginBottom: 4,
      cursor: "ew-resize",
      position: "relative"
    }, onMouseMove: (e) => handleMove(e) },
    import_react3.default.createElement("div", { role: "button", style: {
      border: "2px solid white",
      borderRadius: "50%",
      boxShadow: "0px 0px 3px rgba(0, 0, 0, 0.5)",
      width: "18px",
      height: "18px",
      zIndex: 1e3,
      transition: "all 10ms linear",
      position: "absolute",
      left: (hc == null ? void 0 : hc.h) * ((squareWidth - 18) / 360),
      top: -2,
      cursor: "ew-resize",
      boxSizing: "border-box"
    }, onMouseDown: handleDown }),
    import_react3.default.createElement("canvas", { ref: barRef, height: "14px", width: `${squareWidth}px`, onClick: (e) => handleClick(e), style: { position: "relative", borderRadius: 14, verticalAlign: "top" } })
  );
};
var Hue_default = Hue;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Inputs.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/utils/converters.js
function rgb2cmyk(r, g, b) {
  let computedC = 0;
  let computedM = 0;
  let computedY = 0;
  let computedK = 0;
  if (r === null || g === null || b === null || isNaN(r) || isNaN(g) || isNaN(b)) {
    console.log("Please enter numeric RGB values!");
    return { c: 0, m: 0, k: 0, y: 1 };
  }
  if (r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255) {
    console.log("RGB values must be in the range 0 to 255.");
    return { c: 0, m: 0, k: 0, y: 1 };
  }
  if (r === 0 && g === 0 && b === 0) {
    computedK = 1;
    return { c: 0, m: 0, k: 0, y: 1 };
  }
  computedC = 1 - r / 255;
  computedM = 1 - g / 255;
  computedY = 1 - b / 255;
  const minCMY = Math.min(computedC, Math.min(computedM, computedY));
  computedC = (computedC - minCMY) / (1 - minCMY);
  computedM = (computedM - minCMY) / (1 - minCMY);
  computedY = (computedY - minCMY) / (1 - minCMY);
  computedK = minCMY;
  return { c: computedC, m: computedM, y: computedY, k: computedK };
}
var cmykToRgb = ({ c, m, y, k }) => {
  const r = 255 * (1 - c) * (1 - k);
  const g = 255 * (1 - m) * (1 - k);
  const b = 255 * (1 - y) * (1 - k);
  return { r, g, b };
};

// node_modules/react-best-gradient-color-picker/dist/esm/components/Inputs.js
var import_tinycolor25 = __toESM(require_tinycolor(), 1);
var Input = ({ value, callback, max = 100, label }) => {
  const [temp, setTemp] = (0, import_react4.useState)(value);
  const { hideOpacity, classes } = usePicker();
  const width = hideOpacity ? "22%" : "18%";
  (0, import_react4.useEffect)(() => {
    setTemp(value);
  }, [value]);
  const onChange = (e) => {
    const newVal = formatInputValues(parseFloat(e.target.value), 0, max);
    setTemp(newVal);
    callback(newVal);
  };
  return import_react4.default.createElement(
    "div",
    { style: { width } },
    import_react4.default.createElement("input", { value: temp, id: "rbgcp-input", onChange: (e) => onChange(e), className: classes.rbgcpInput }),
    import_react4.default.createElement("div", { className: classes.rbgcpInputLabel }, label)
  );
};
var HexInput = ({ opacity }) => {
  const { handleChange, tinyColor, classes } = usePicker();
  const [disable, setDisable] = (0, import_react4.useState)("");
  const hex = tinyColor.toHex();
  const [newHex, setNewHex] = (0, import_react4.useState)(hex);
  (0, import_react4.useEffect)(() => {
    if (disable !== "hex") {
      setNewHex(hex);
    }
  }, [tinyColor, disable, hex]);
  const hexFocus = () => {
    setDisable("hex");
  };
  const hexBlur = () => {
    setDisable("");
  };
  const handleHex = (e) => {
    const tinyHex = (0, import_tinycolor25.default)(e.target.value);
    setNewHex(e.target.value);
    if (tinyHex.isValid()) {
      const { r, g, b } = tinyHex.toRgb();
      const newColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
      handleChange(newColor);
    }
  };
  return import_react4.default.createElement(
    "div",
    { style: { width: "23%" } },
    import_react4.default.createElement("input", { value: newHex, onBlur: hexBlur, onFocus: hexFocus, id: "rbgcp-hex-input", onChange: (e) => handleHex(e), className: `${classes.rbgcpInput} ${classes.rbgcpHexInput}` }),
    import_react4.default.createElement("div", { className: classes.rbgcpInputLabel }, "HEX")
  );
};
var RGBInputs = () => {
  const { handleChange, hc } = usePicker();
  const handleRgb = ({ r, g, b }) => {
    handleChange(`rgba(${r}, ${g}, ${b}, ${hc == null ? void 0 : hc.a})`);
  };
  return import_react4.default.createElement(
    import_react4.default.Fragment,
    null,
    import_react4.default.createElement(Input, { value: hc == null ? void 0 : hc.r, callback: (newVal) => handleRgb({ r: newVal, g: hc == null ? void 0 : hc.g, b: hc == null ? void 0 : hc.b }), label: "R", max: 255 }),
    import_react4.default.createElement(Input, { value: hc == null ? void 0 : hc.g, callback: (newVal) => handleRgb({ r: hc == null ? void 0 : hc.r, g: newVal, b: hc == null ? void 0 : hc.b }), label: "G", max: 255 }),
    import_react4.default.createElement(Input, { value: hc == null ? void 0 : hc.b, callback: (newVal) => handleRgb({ r: hc == null ? void 0 : hc.r, g: hc == null ? void 0 : hc.g, b: newVal }), label: "B", max: 255 })
  );
};
var HSLInputs = () => {
  const { handleChange, tinyColor, setHc, hc } = usePicker();
  const { s, l } = tinyColor.toHsl();
  const handleH = (h, s2, l2) => {
    const { r, g, b } = (0, import_tinycolor25.default)({ h, s: s2, l: l2 }).toRgb();
    handleChange(`rgba(${r}, ${g}, ${b}, ${hc == null ? void 0 : hc.a})`);
    setHc({ ...hc, h });
  };
  const handleSl = (value) => {
    const { r, g, b } = (0, import_tinycolor25.default)(value).toRgb();
    handleChange(`rgba(${r}, ${g}, ${b}, ${hc == null ? void 0 : hc.a})`);
  };
  return import_react4.default.createElement(
    import_react4.default.Fragment,
    null,
    import_react4.default.createElement(Input, { value: round(hc == null ? void 0 : hc.h), callback: (newVal) => handleH(newVal, s, l), label: "H", max: 360 }),
    import_react4.default.createElement(Input, { value: round(s * 100), callback: (newVal) => handleSl({ h: hc == null ? void 0 : hc.h, s: newVal, l }), label: "S" }),
    import_react4.default.createElement(Input, { value: round(l * 100), callback: (newVal) => handleSl({ h: hc == null ? void 0 : hc.h, s, l: newVal }), label: "L" })
  );
};
var HSVInputs = () => {
  const { handleChange, setHc, hc } = usePicker();
  const handleH = (h, s, v) => {
    const { r, g, b } = (0, import_tinycolor25.default)({ h, s, v }).toRgb();
    handleChange(`rgba(${r}, ${g}, ${b}, ${hc == null ? void 0 : hc.a})`);
    setHc({ ...hc, h });
  };
  const handleSV = (value) => {
    const { r, g, b } = (0, import_tinycolor25.default)(value).toRgb();
    handleChange(`rgba(${r}, ${g}, ${b}, ${hc == null ? void 0 : hc.a})`);
  };
  return import_react4.default.createElement(
    import_react4.default.Fragment,
    null,
    import_react4.default.createElement(Input, { value: round(hc == null ? void 0 : hc.h), callback: (newVal) => handleH(newVal, hc == null ? void 0 : hc.s, hc == null ? void 0 : hc.v), label: "H", max: 360 }),
    import_react4.default.createElement(Input, { value: round((hc == null ? void 0 : hc.s) * 100), callback: (newVal) => handleSV({ h: hc == null ? void 0 : hc.h, s: newVal, v: hc == null ? void 0 : hc.v }), label: "S" }),
    import_react4.default.createElement(Input, { value: round((hc == null ? void 0 : hc.v) * 100), callback: (newVal) => handleSV({ h: hc == null ? void 0 : hc.h, s: hc == null ? void 0 : hc.s, v: newVal }), label: "V" })
  );
};
var CMKYInputs = () => {
  const { handleChange, hc } = usePicker();
  const { c, m, y, k } = rgb2cmyk(hc == null ? void 0 : hc.r, hc == null ? void 0 : hc.g, hc == null ? void 0 : hc.b);
  const handleCmyk = (value) => {
    const { r, g, b } = cmykToRgb(value);
    handleChange(`rgba(${r}, ${g}, ${b}, ${hc == null ? void 0 : hc.a})`);
  };
  return import_react4.default.createElement(
    import_react4.default.Fragment,
    null,
    import_react4.default.createElement(Input, { value: round(c * 100), callback: (newVal) => handleCmyk({ c: newVal / 100, m, y, k }), label: "C" }),
    import_react4.default.createElement(Input, { value: round(m * 100), callback: (newVal) => handleCmyk({ c, m: newVal / 100, y, k }), label: "M" }),
    import_react4.default.createElement(Input, { value: round(y * 100), callback: (newVal) => handleCmyk({ c, m, y: newVal / 100, k }), label: "Y" }),
    import_react4.default.createElement(Input, { value: round(k * 100), callback: (newVal) => handleCmyk({ c, m, y, k: newVal / 100 }), label: "K" })
  );
};
var Inputs = () => {
  const { handleChange, inputType, hideOpacity, hc, classes } = usePicker();
  return import_react4.default.createElement(
    "div",
    { style: {
      paddingTop: 14,
      display: "flex",
      justifyContent: "space-between"
    }, id: "rbgcp-inputs-wrap", className: classes.rbgcpInputsWrap },
    inputType !== "cmyk" && import_react4.default.createElement(HexInput, { opacity: hc == null ? void 0 : hc.a }),
    inputType === "hsl" && import_react4.default.createElement(HSLInputs, null),
    inputType === "rgb" && import_react4.default.createElement(RGBInputs, null),
    inputType === "hsv" && import_react4.default.createElement(HSVInputs, null),
    inputType === "cmyk" && import_react4.default.createElement(CMKYInputs, null),
    !hideOpacity && import_react4.default.createElement(Input, { value: Math.round((hc == null ? void 0 : hc.a) * 100), callback: (newVal) => handleChange(`rgba(${hc == null ? void 0 : hc.r}, ${hc == null ? void 0 : hc.g}, ${hc == null ? void 0 : hc.b}, ${newVal / 100})`), label: "A" })
  );
};
var Inputs_default = Inputs;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Square.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/hooks/usePaintSquare.js
var import_react5 = __toESM(require_react(), 1);
var usePaintSquare = (canvas, hue, squareWidth, squareHeight) => {
  (0, import_react5.useEffect)(() => {
    if (canvas.current) {
      const ctx = canvas.current.getContext("2d", { willReadFrequently: true });
      if (ctx) {
        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.fillRect(0, 0, squareWidth, squareHeight);
        const gradientWhite = ctx.createLinearGradient(0, 0, squareWidth, 0);
        gradientWhite.addColorStop(0, `rgba(255, 255, 255, 1)`);
        gradientWhite.addColorStop(1, `rgba(255, 255, 255, 0)`);
        ctx.fillStyle = gradientWhite;
        ctx.fillRect(0, 0, squareWidth, squareHeight);
        const gradientBlack = ctx.createLinearGradient(0, 0, 0, squareHeight);
        gradientBlack.addColorStop(0, `rgba(0, 0, 0, 0)`);
        gradientBlack.addColorStop(1, `rgba(0, 0, 0, 1)`);
        ctx.fillStyle = gradientBlack;
        ctx.fillRect(0, 0, squareWidth, squareHeight);
      }
    }
  }, [canvas, hue, squareWidth, squareHeight]);
};
var usePaintSquare_default = usePaintSquare;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Square.js
var import_lodash = __toESM(require_lodash(), 1);
var import_tinycolor26 = __toESM(require_tinycolor(), 1);
var { crossSize: crossSize2 } = config;
var Square = () => {
  const { hc, classes, squareWidth, squareHeight, handleChange } = usePicker();
  const [dragging, setDragging] = (0, import_react6.useState)(false);
  const canvas = (0, import_react6.useRef)(null);
  const [x, y] = computeSquareXY(hc == null ? void 0 : hc.s, (hc == null ? void 0 : hc.v) * 100, squareWidth, squareHeight);
  const [dragPos, setDragPos] = (0, import_react6.useState)({ x, y });
  usePaintSquare_default(canvas, hc == null ? void 0 : hc.h, squareWidth, squareHeight);
  (0, import_react6.useEffect)(() => {
    if (!dragging) {
      setDragPos({ x: (hc == null ? void 0 : hc.v) === 0 ? dragPos.x : x, y });
    }
  }, [x, y]);
  const handleColor = (e) => {
    const onMouseMove = (0, import_lodash.default)(() => {
      const [x2, y2] = computePickerPosition(e);
      if (x2 && y2) {
        const x1 = Math.min(x2 + crossSize2 / 2, squareWidth - 1);
        const y1 = Math.min(y2 + crossSize2 / 2, squareHeight - 1);
        const newS = x1 / squareWidth * 100;
        const newY = 100 - y1 / squareHeight * 100;
        setDragPos({ x: newY === 0 ? dragPos == null ? void 0 : dragPos.x : x2, y: y2 });
        const updated = (0, import_tinycolor26.default)(`hsva(${hc == null ? void 0 : hc.h}, ${newS}%, ${newY}%, ${hc == null ? void 0 : hc.a})`);
        handleChange(updated.toRgbString());
      }
    }, 250);
    onMouseMove();
  };
  const stopDragging = () => {
    setDragging(false);
  };
  const handleMove = (e) => {
    if (dragging) {
      handleColor(e);
    }
  };
  const handleClick = (e) => {
    if (!dragging) {
      handleColor(e);
    }
  };
  const handleMouseDown = () => {
    setDragging(true);
  };
  const handleCanvasDown = (e) => {
    setDragging(true);
    handleColor(e);
  };
  (0, import_react6.useEffect)(() => {
    const handleUp = () => {
      stopDragging();
    };
    window.addEventListener("mouseup", handleUp);
    return () => {
      window.removeEventListener("mouseup", handleUp);
    };
  }, []);
  return import_react6.default.createElement(
    "div",
    { style: { position: "relative" } },
    import_react6.default.createElement(
      "div",
      { onMouseUp: stopDragging, onTouchEnd: stopDragging, onMouseDown: handleCanvasDown, onTouchStart: handleCanvasDown, onMouseMove: (e) => handleMove(e), style: { position: "relative", cursor: "ew-cross" } },
      import_react6.default.createElement("div", { className: classes.rbgcpHandle, style: {
        left: dragPos == null ? void 0 : dragPos.x,
        top: dragPos == null ? void 0 : dragPos.y
      }, onMouseDown: handleMouseDown, role: "button", tabIndex: 0 }),
      import_react6.default.createElement(
        "div",
        { className: classes.rbgcpCanvasWrapper, style: { height: squareHeight }, onClick: (e) => handleClick(e) },
        import_react6.default.createElement("canvas", { ref: canvas, id: "paintSquare", width: `${squareWidth}px`, height: `${squareHeight}px` })
      )
    )
  );
};
var Square_default = Square;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Opacity.js
var import_react7 = __toESM(require_react(), 1);
var Opacity = () => {
  const { handleChange, hc = {}, squareWidth, classes } = usePicker();
  const [dragging, setDragging] = (0, import_react7.useState)(false);
  const { r, g, b } = hc;
  const bg = `linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(${r},${g},${b},.5) 100%)`;
  const stopDragging = () => {
    setDragging(false);
  };
  const handleDown = () => {
    setDragging(true);
  };
  const handleOpacity = (e) => {
    const newO = getHandleValue(e) / 100;
    const newColor = `rgba(${r}, ${g}, ${b}, ${newO})`;
    handleChange(newColor);
  };
  const handleMove = (e) => {
    if (dragging) {
      handleOpacity(e);
    }
  };
  const handleClick = (e) => {
    if (!dragging) {
      handleOpacity(e);
    }
  };
  const left = squareWidth - 18;
  (0, import_react7.useEffect)(() => {
    const handleUp = () => {
      stopDragging();
    };
    window.addEventListener("mouseup", handleUp);
    return () => {
      window.removeEventListener("mouseup", handleUp);
    };
  }, []);
  return import_react7.default.createElement(
    "div",
    { onMouseDown: handleDown, onMouseMove: (e) => handleMove(e), style: {
      height: 14,
      marginTop: 17,
      marginBottom: 4,
      cursor: "ew-resize",
      position: "relative"
    } },
    import_react7.default.createElement("div", { style: { width: "100%", height: 14 }, className: classes.rbgcpCheckered }),
    import_react7.default.createElement("div", { style: { left: left * (hc == null ? void 0 : hc.a), top: -2 }, className: classes.rbgcpHandle }),
    import_react7.default.createElement("div", { style: { background: bg }, onClick: (e) => handleClick(e), className: classes.rbgcpOpacityOverlay })
  );
};
var Opacity_default = Opacity;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Presets.js
var import_react8 = __toESM(require_react(), 1);
var Presets = ({ presets = [] }) => {
  const { value, onChange, handleChange, squareWidth } = usePicker();
  const getPresets = () => {
    if ((presets == null ? void 0 : presets.length) > 0) {
      return presets == null ? void 0 : presets.slice(0, 18);
    } else {
      return fakePresets;
    }
  };
  const handlePresetClick = (preset) => {
    if (preset == null ? void 0 : preset.includes("gradient")) {
      onChange(preset);
    } else {
      handleChange(preset);
    }
  };
  return import_react8.default.createElement(
    "div",
    { style: {
      display: "flex",
      marginTop: 14,
      justifyContent: "space-between"
    } },
    import_react8.default.createElement("div", { style: {
      width: 50,
      height: 50,
      background: value,
      borderRadius: 6,
      flexShrink: 0
    } }),
    import_react8.default.createElement("div", { style: {
      display: "flex",
      flexWrap: "wrap",
      width: squareWidth - 66,
      justifyContent: "space-between"
    } }, getPresets().map((p, key) => import_react8.default.createElement("div", { key: `${p}-${key}`, style: {
      height: 23,
      width: "10.2%",
      borderRadius: 4,
      background: p,
      marginBottom: 2,
      border: p === "rgba(255,255,255, 1)" ? "1px solid #96959c" : ""
    }, onClick: () => handlePresetClick(p) })))
  );
};
var Presets_default = Presets;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Controls.js
var import_react15 = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/components/icon.js
var import_react9 = __toESM(require_react(), 1);
var TrashIcon = () => {
  const { classes } = usePicker();
  const styles = {
    fill: "none",
    strokeWidth: "1.8px"
  };
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 15 } },
    import_react9.default.createElement("polyline", { style: styles, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, points: "17.96 4.31 2.04 4.3 3.75 4.3 4.81 17.29 5.16 17.96 5.74 18.47 6.59 18.62 13.64 18.62 14.52 18.32 15.07 17.68 15.29 17.12 16.28 4.3 12.87 4.3 12.87 2.38 12.48 1.75 11.83 1.46 8.4 1.46 7.64 1.68 7.26 2.21 7.16 2.52 7.17 4.23" })
  );
};
var icon_default = TrashIcon;
var LinearIcon = ({ color }) => {
  const { classes } = usePicker();
  const col = color || "";
  const styles = {
    fill: "none",
    stroke: col,
    strokeWidth: "1.8px"
  };
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 14 } },
    import_react9.default.createElement("polyline", { style: styles, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, points: "0.9 12.73 0.9 19.1 7.27 19.1 0.9 19.1 19.1 0.9 12.73 0.9 19.1 0.9 19.1 7.27" })
  );
};
var RadialIcon = ({ color }) => {
  const { classes } = usePicker();
  const col = color || "";
  const styles = {
    fill: "none",
    stroke: col,
    strokeMiterlimit: 10,
    strokeWidth: "1.8px"
  };
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 15 } },
    import_react9.default.createElement("circle", { style: styles, className: classes.rbgcpControlIcon, cx: "10", cy: "10", r: "9" }),
    import_react9.default.createElement("circle", { style: styles, className: classes.rbgcpControlIcon, cx: "10", cy: "10", r: "5" })
  );
};
var SlidersIcon = ({ color }) => {
  const { classes } = usePicker();
  const col = color || "";
  const style1 = {
    fill: "none",
    stroke: col,
    strokeWidth: "1.8px"
  };
  const style2 = {
    fill: col,
    stroke: col,
    strokeWidth: "1.8px"
  };
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 17 } },
    import_react9.default.createElement("polyline", { style: style1, fillRule: "evenodd", strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, points: "3.74 2.75 3.74 12.69 0.9 12.71 6.59 12.71" }),
    import_react9.default.createElement("line", { style: style2, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, x1: "3.74", y1: "17.26", x2: "3.74", y2: "15.21" }),
    import_react9.default.createElement("polyline", { style: style1, fillRule: "evenodd", strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, points: "10.1 17.25 10.1 7.31 12.95 7.29 7.26 7.29" }),
    import_react9.default.createElement("line", { style: style2, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, x1: "10.1", y1: "2.74", x2: "10.1", y2: "4.79" }),
    import_react9.default.createElement("polyline", { style: style1, fillRule: "evenodd", strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, points: "16.26 2.75 16.26 12.69 13.41 12.71 19.1 12.71" }),
    import_react9.default.createElement("line", { style: style2, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, x1: "16.26", y1: "17.26", x2: "16.26", y2: "15.21" })
  );
};
var InputsIcon = ({ color }) => {
  const { classes } = usePicker();
  const col = color || "";
  const style1 = {
    fill: "none",
    stroke: col,
    strokeWidth: "1.8px"
  };
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 17 } },
    import_react9.default.createElement("path", { style: style1, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, d: "M6.35,2.72a4.85,4.85,0,0,1,1.86.16,7.94,7.94,0,0,1,.88.43,3.66,3.66,0,0,0,.85.49c.25,0,.58-.27.81-.39A8.25,8.25,0,0,1,11.7,3a4,4,0,0,1,1.79-.23,3.21,3.21,0,0,0-1.34.09,6.39,6.39,0,0,0-1.47.63c-.45.25-.7.3-.7.86s0,1.18,0,1.78c0,1.3,0,2.61,0,3.92h0v5.63a2.46,2.46,0,0,1,0,.47c-.07.28-.43.42-.7.57a5.29,5.29,0,0,1-2.94.61A9.3,9.3,0,0,0,8,17.15l1.09-.37.89-.52c.06,0,.48.21.56.25.32.14.64.27,1,.38a8.54,8.54,0,0,0,2.12.4" }),
    import_react9.default.createElement("path", { style: style1, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, d: "M7.57,5.73C6,5.7,4.5,5.65,3,5.77a2.28,2.28,0,0,0-1.76.74A2.3,2.3,0,0,0,.94,7.83l0,3.82A4.73,4.73,0,0,0,1,12.9a1.64,1.64,0,0,0,.68,1,2.44,2.44,0,0,0,1,.27,25,25,0,0,0,4.74.09" }),
    import_react9.default.createElement("path", { style: style1, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, d: "M12.43,14.32a44.12,44.12,0,0,0,4.6,0,2.24,2.24,0,0,0,1.76-.74,2.29,2.29,0,0,0,.27-1.32l0-3.81A4.81,4.81,0,0,0,19,7.15a1.62,1.62,0,0,0-.68-1,2.31,2.31,0,0,0-1-.28,26.8,26.8,0,0,0-4.74-.09" })
  );
};
var PaletteIcon = ({ color }) => {
  const { classes } = usePicker();
  const col = color || "";
  const style1 = { fill: col };
  const style2 = {
    fill: col,
    stroke: col,
    strokeMiterlimit: 10,
    strokeWidth: "0.5px"
  };
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 17 } },
    import_react9.default.createElement("circle", { style: style1, className: classes.rbgcpControlIcon2, cx: "9.36", cy: "5.07", r: "1.71" }),
    import_react9.default.createElement("circle", { style: style1, className: classes.rbgcpControlIcon2, cx: "13.93", cy: "6.91", r: "1.71" }),
    import_react9.default.createElement("circle", { style: style1, className: classes.rbgcpControlIcon2, cx: "5.8", cy: "7.55", r: "1.71" }),
    import_react9.default.createElement("circle", { style: style1, className: classes.rbgcpControlIcon2, cx: "5.45", cy: "12.04", r: "1.71" }),
    import_react9.default.createElement("path", { style: style2, className: `${classes.rbgcpControlIcon1} ${classes.rbgcpControlIcon2}`, d: "M19.1,10c0,3.58-2.12,2.94-4.06,2.35-1.15-.34-2.24-.67-2.77-.08-.68.78-.54,2.07-.39,3.33.2,1.79.39,3.5-1.88,3.5A9.1,9.1,0,1,1,19.1,10ZM10,18c.7,0,.74-.19.75-.2a2.67,2.67,0,0,0,.07-1.27c0-.19,0-.42-.06-.67-.06-.53-.13-1.15-.14-1.67a3.82,3.82,0,0,1,.8-2.63,2.14,2.14,0,0,1,1.45-.7,4.36,4.36,0,0,1,1.32.12c.39.08.8.21,1.16.32h0c.39.12.74.23,1.08.3.74.17,1,.1,1.13,0S18,11.32,18,10a8,8,0,1,0-8,8Z" })
  );
};
var DegreesIcon = ({ color }) => {
  const { classes } = usePicker();
  const col = color || "";
  const style2 = {
    fill: "none",
    stroke: col,
    strokeMiterlimit: 10,
    strokeWidth: "1.8px"
  };
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 15 } },
    import_react9.default.createElement("polyline", { style: style2, strokeLinecap: "round", className: classes.rbgcpControlIcon, points: "13.86 2.01 1.7 16.99 18.77 16.99" }),
    import_react9.default.createElement("polyline", { style: style2, strokeLinecap: "round", className: classes.rbgcpControlIcon, points: "10.96 16.38 10.96 16.38 10.74 15.7 10.44 14.97 10.06 14.21 9.72 13.63 9.21 12.89 8.85 12.44 8.41 11.95 7.91 11.45 7.51 11.1" })
  );
};
var StopIcon = () => {
  const { classes } = usePicker();
  return import_react9.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 20, marginRight: 1 } },
    import_react9.default.createElement("path", { className: classes.rbgcpControlIcon2, d: "M2.39,8c-.63,0-1,.21-1,.63A.49.49,0,0,0,1.67,9a6.48,6.48,0,0,0,1.11.43A3,3,0,0,1,4,10.09a1.47,1.47,0,0,1,.35,1.09,1.75,1.75,0,0,1-.57,1.42,2.21,2.21,0,0,1-1.48.48,8.32,8.32,0,0,1-1.68-.21l-.31-.06.12-.94a13.7,13.7,0,0,0,1.8.16c.61,0,.92-.26.92-.77a.52.52,0,0,0-.21-.44,3.13,3.13,0,0,0-.85-.34A3.32,3.32,0,0,1,.66,9.79a1.43,1.43,0,0,1-.42-1.1A1.6,1.6,0,0,1,.78,7.36a2.32,2.32,0,0,1,1.49-.44,10.46,10.46,0,0,1,1.64.17l.32.07-.1.95C3.31,8,2.73,8,2.39,8Z" }),
    import_react9.default.createElement("path", { className: classes.rbgcpControlIcon2, d: "M4.79,8.09V7H9.16V8.09H7.59V13H6.38V8.09Z" }),
    import_react9.default.createElement("path", { className: classes.rbgcpControlIcon2, d: "M14,12.34a2.25,2.25,0,0,1-1.91.74,2.24,2.24,0,0,1-1.91-.74A3.85,3.85,0,0,1,9.61,10a4,4,0,0,1,.56-2.34,2.2,2.2,0,0,1,1.91-.77A2.21,2.21,0,0,1,14,7.69,4,4,0,0,1,14.55,10,3.85,3.85,0,0,1,14,12.34Zm-2.88-.77a1,1,0,0,0,1,.46,1,1,0,0,0,1-.46A3.25,3.25,0,0,0,13.3,10,3.45,3.45,0,0,0,13,8.46a1,1,0,0,0-1-.49,1,1,0,0,0-1,.49A3.43,3.43,0,0,0,10.85,10,3.38,3.38,0,0,0,11.11,11.57Z" }),
    import_react9.default.createElement("path", { className: classes.rbgcpControlIcon2, d: "M17.77,11.24h-1V13H15.58V7h2.19a1.85,1.85,0,0,1,2.11,2.07,2.21,2.21,0,0,1-.54,1.6A2.07,2.07,0,0,1,17.77,11.24Zm-1-1h1c.6,0,.9-.37.9-1.12a1.18,1.18,0,0,0-.22-.79.88.88,0,0,0-.68-.24h-1Z" })
  );
};

// node_modules/react-best-gradient-color-picker/dist/esm/components/EyeDropper.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/react-best-gradient-color-picker/dist/esm/components/Portal.js
var import_react10 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var Portal = ({ children }) => {
  const id = "id" + Math.random().toString(16).slice(2);
  const el = (0, import_react10.useRef)(document.getElementById(id) || document.createElement("div"));
  const [dynamic] = (0, import_react10.useState)(!el.current.parentElement);
  (0, import_react10.useEffect)(() => {
    const refValue = el.current;
    if (dynamic) {
      el.current.id = id;
      document.body.appendChild(el.current);
    }
    return () => {
      if (dynamic && refValue.parentElement) {
        refValue.parentElement.removeChild(refValue);
      }
    };
  }, [id]);
  return (0, import_react_dom.createPortal)(children, el.current);
};
var Portal_default = (0, import_react10.memo)(Portal);

// node_modules/react-best-gradient-color-picker/dist/esm/components/EyeDropper.js
var import_tinycolor27 = __toESM(require_tinycolor(), 1);
var DropperIcon = ({ color }) => {
  const { classes } = usePicker();
  const col = color || "";
  const style1 = {
    fill: "none",
    stroke: col,
    strokeWidth: "1.4px"
  };
  const style2 = {
    fill: col,
    stroke: col,
    strokeWidth: "1.4px"
  };
  return import_react11.default.createElement(
    "svg",
    { id: "Layer_1", "data-name": "Layer 1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", style: { width: 16 } },
    import_react11.default.createElement("path", { style: style1, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon, d: "M15.6,7h0L7.78,14.86c-.37.37-1.61.38-2,.75s-.5,1.53-.76,2a3.53,3.53,0,0,1-.52.52,1.6,1.6,0,0,1-2.27-.06l-.32-.32a1.61,1.61,0,0,1-.06-2.27A3.25,3.25,0,0,1,2.4,15c.47-.26,1.65-.35,2-.73s.34-1.64.71-2c1.68-1.73,5.61-5.65,7.91-7.93h0l1.14,1.38L15.6,7Z" }),
    import_react11.default.createElement("polygon", { style: style2, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon2, points: "15.7 8.87 11.13 4.29 12.69 2.73 17.25 7.31 15.7 8.87" }),
    import_react11.default.createElement("path", { style: style2, strokeLinecap: "round", strokeLinejoin: "round", className: classes.rbgcpControlIcon2, d: "M18.18,3.71,16.36,5.53a1.33,1.33,0,0,1-1.88,0h0a1.34,1.34,0,0,1,0-1.89l1.81-1.82a1.34,1.34,0,0,1,1.89,0h0A1.34,1.34,0,0,1,18.18,3.71Z" })
  );
};
var Dropper = ({ onSelect }) => {
  const { classes } = usePicker();
  const [pickerCanvas, setPickerCanvas] = (0, import_react11.useState)(null);
  const [coverUp, setCoverUp] = (0, import_react11.useState)(false);
  const takePick = () => {
    const root = document.getElementById("root");
    setCoverUp(true);
    html2canvas_esm_default(root).then((canvas) => {
      const blankCanvas = document.createElement("canvas");
      const ctx = blankCanvas.getContext("2d", { willReadFrequently: true });
      if (root && ctx) {
        blankCanvas.width = root.offsetWidth * 2;
        blankCanvas.height = root.offsetHeight * 2;
        ctx.drawImage(canvas, 0, 0);
      }
      setPickerCanvas(ctx);
    });
  };
  const getColorLegacy = (e) => {
    e.stopPropagation();
    if (pickerCanvas) {
      const { pageX, pageY } = e;
      const x1 = pageX * 2;
      const y1 = pageY * 2;
      const [r, g, b] = pickerCanvas.getImageData(x1, y1, 1, 1).data;
      onSelect(`rgba(${r}, ${g}, ${b}, 1)`);
    }
    setCoverUp(false);
  };
  const getEyeDrop = () => {
    if (!window.EyeDropper) {
      takePick();
    } else {
      const eyeDropper = new window.EyeDropper();
      const abortController = new window.AbortController();
      eyeDropper.open({ signal: abortController.signal }).then((result) => {
        const tinyHex = (0, import_tinycolor27.default)(result.sRGBHex);
        const { r, g, b } = tinyHex.toRgb();
        onSelect(`rgba(${r}, ${g}, ${b}, 1)`);
      }).catch((e) => {
        console.log(e);
      });
    }
  };
  return import_react11.default.createElement(
    "div",
    null,
    import_react11.default.createElement(
      "div",
      { onClick: getEyeDrop, id: "rbgcp-eyedropper-btn", className: `${controlBtnStyles(coverUp, classes)} ${classes.rbgcpEyedropperBtn}` },
      import_react11.default.createElement(DropperIcon, { color: coverUp ? "rgb(86, 140, 245)" : "" })
    ),
    coverUp && import_react11.default.createElement(
      Portal_default,
      null,
      import_react11.default.createElement("div", { onClick: (e) => getColorLegacy(e), className: classes.rbgcpEyedropperCover })
    )
  );
};
var EyeDropper_default = Dropper;

// node_modules/react-best-gradient-color-picker/dist/esm/components/AdvancedControls.js
var import_react12 = __toESM(require_react(), 1);
var import_tinycolor28 = __toESM(require_tinycolor(), 1);
var AdvBar = ({ value, callback, reffy, openAdvanced, label }) => {
  const { squareWidth, classes } = usePicker();
  const [dragging, setDragging] = (0, import_react12.useState)(false);
  const [handleTop, setHandleTop] = (0, import_react12.useState)(2);
  const left = value * (squareWidth - 18);
  (0, import_react12.useEffect)(() => {
    var _a;
    setHandleTop(((_a = reffy == null ? void 0 : reffy.current) == null ? void 0 : _a.offsetTop) - 2);
  }, [openAdvanced, reffy]);
  const stopDragging = () => {
    setDragging(false);
  };
  const handleMove = (e) => {
    if (dragging) {
      callback(getHandleValue(e));
    }
  };
  const handleClick = (e) => {
    if (!dragging) {
      callback(getHandleValue(e));
    }
  };
  const handleDown = () => {
    setDragging(true);
  };
  (0, import_react12.useEffect)(() => {
    const handleUp = () => {
      stopDragging();
    };
    window.addEventListener("mouseup", handleUp);
    return () => {
      window.removeEventListener("mouseup", handleUp);
    };
  }, []);
  return import_react12.default.createElement(
    "div",
    { style: { width: "100%", padding: "3px 0px 3px 0px" } },
    import_react12.default.createElement(
      "div",
      { onMouseMove: (e) => handleMove(e), className: `${classes.cResize} ${classes.psRl}` },
      import_react12.default.createElement("div", { style: { left, top: handleTop }, className: classes.rbgcpHandle, onMouseDown: handleDown, role: "button", tabIndex: 0 }),
      import_react12.default.createElement("div", { style: {
        textAlign: "center",
        color: "#fff",
        fontSize: 12,
        fontWeight: 500,
        lineHeight: 1,
        position: "absolute",
        left: "50%",
        transform: "translate(-50%, 0%)",
        top: handleTop + 2,
        zIndex: 10,
        textShadow: "1px 1px 1px rgba(0,0,0,.6)"
      }, onMouseMove: (e) => handleMove(e), onClick: (e) => handleClick(e) }, label),
      import_react12.default.createElement("canvas", { ref: reffy, height: "14px", width: `${squareWidth}px`, onClick: (e) => handleClick(e), style: { position: "relative", borderRadius: 14 } })
    )
  );
};
var AdvancedControls = ({ openAdvanced }) => {
  const { tinyColor, handleChange, squareWidth, hc } = usePicker();
  const { s, l } = tinyColor.toHsl();
  const satRef = (0, import_react12.useRef)(null);
  const lightRef = (0, import_react12.useRef)(null);
  const brightRef = (0, import_react12.useRef)(null);
  usePaintSat(satRef, hc == null ? void 0 : hc.h, l * 100, squareWidth);
  usePaintLight(lightRef, hc == null ? void 0 : hc.h, s * 100, squareWidth);
  usePaintBright(brightRef, hc == null ? void 0 : hc.h, s * 100, squareWidth);
  const satDesat = (value) => {
    const { r, g, b } = (0, import_tinycolor28.default)({ h: hc == null ? void 0 : hc.h, s: value / 100, l }).toRgb();
    handleChange(`rgba(${r},${g},${b},${hc == null ? void 0 : hc.a})`);
  };
  const setLight = (value) => {
    const { r, g, b } = (0, import_tinycolor28.default)({ h: hc == null ? void 0 : hc.h, s, l: value / 100 }).toRgb();
    handleChange(`rgba(${r},${g},${b},${hc == null ? void 0 : hc.a})`);
  };
  const setBright = (value) => {
    const { r, g, b } = (0, import_tinycolor28.default)({
      h: hc == null ? void 0 : hc.h,
      s: (hc == null ? void 0 : hc.s) * 100,
      v: value
    }).toRgb();
    handleChange(`rgba(${r},${g},${b},${hc == null ? void 0 : hc.a})`);
  };
  return import_react12.default.createElement(
    "div",
    { style: {
      height: openAdvanced ? 98 : 0,
      width: "100%",
      transition: "all 120ms linear"
    } },
    import_react12.default.createElement(
      "div",
      { style: {
        paddingTop: 11,
        display: openAdvanced ? "flex" : "none",
        flexDirection: "column",
        justifyContent: "space-between",
        height: openAdvanced ? 98 : 0,
        overflow: "hidden",
        transition: "height 100ms linear"
      } },
      import_react12.default.createElement(AdvBar, { value: s, reffy: satRef, callback: satDesat, openAdvanced, label: "Saturation" }),
      import_react12.default.createElement(AdvBar, { value: l, reffy: lightRef, label: "Lightness", callback: setLight, openAdvanced }),
      import_react12.default.createElement(AdvBar, { value: hc == null ? void 0 : hc.v, reffy: brightRef, label: "Brightness", callback: setBright, openAdvanced })
    )
  );
};
var AdvancedControls_default = AdvancedControls;

// node_modules/react-best-gradient-color-picker/dist/esm/components/ComparibleColors.js
var import_react13 = __toESM(require_react(), 1);
var ComparibleColors = ({ openComparibles }) => {
  const { tinyColor, handleChange, classes } = usePicker();
  const analogous = tinyColor.analogous();
  const monochromatic = tinyColor.monochromatic();
  const triad = tinyColor.triad();
  const tetrad = tinyColor.tetrad();
  const handleClick = (tiny) => {
    const { r, g, b, a } = tiny.toRgb();
    handleChange(`rgba(${r},${g},${b},${a})`);
  };
  return import_react13.default.createElement(
    "div",
    { style: {
      height: openComparibles ? 216 : 0,
      width: "100%",
      transition: "all 120ms linear"
    } },
    import_react13.default.createElement(
      "div",
      { style: {
        paddingTop: 11,
        display: openComparibles ? "" : "none",
        position: "relative"
      } },
      import_react13.default.createElement("div", { style: {
        textAlign: "center",
        fontSize: 13,
        fontWeight: 600,
        position: "absolute",
        top: 6.5,
        left: 2
      }, className: classes.rbgcpComparibleLabel }, "Color Guide"),
      import_react13.default.createElement("div", { style: {
        textAlign: "center",
        fontSize: 12,
        fontWeight: 500,
        marginTop: 3
      }, className: classes.rbgcpComparibleLabel }, "Analogous"),
      import_react13.default.createElement("div", { style: { borderRadius: 5, overflow: "hidden", display: "flex" } }, analogous == null ? void 0 : analogous.map((c, key) => import_react13.default.createElement("div", { key, style: { width: "20%", height: 30, background: c.toHexString() }, onClick: () => handleClick(c) }))),
      import_react13.default.createElement("div", { style: {
        textAlign: "center",
        fontSize: 12,
        fontWeight: 500,
        marginTop: 3
      }, className: classes.rbgcpComparibleLabel }, "Monochromatic"),
      import_react13.default.createElement("div", { style: {
        borderRadius: 5,
        overflow: "hidden",
        display: "flex",
        justifyContent: "flex-end"
      } }, monochromatic == null ? void 0 : monochromatic.map((c, key) => import_react13.default.createElement("div", { key, style: { width: "20%", height: 30, background: c.toHexString() }, onClick: () => handleClick(c) }))),
      import_react13.default.createElement("div", { style: {
        textAlign: "center",
        fontSize: 12,
        fontWeight: 500,
        marginTop: 3
      }, className: classes.rbgcpComparibleLabel }, "Triad"),
      import_react13.default.createElement("div", { style: {
        borderRadius: 5,
        overflow: "hidden",
        display: "flex",
        justifyContent: "flex-end"
      } }, triad == null ? void 0 : triad.map((c, key) => import_react13.default.createElement("div", { key, style: {
        width: "calc(100% / 3)",
        height: 28,
        background: c.toHexString()
      }, onClick: () => handleClick(c) }))),
      import_react13.default.createElement("div", { style: {
        textAlign: "center",
        fontSize: 12,
        fontWeight: 500,
        marginTop: 3
      }, className: classes.rbgcpComparibleLabel }, "Tetrad"),
      import_react13.default.createElement("div", { style: {
        borderRadius: 5,
        overflow: "hidden",
        display: "flex",
        justifyContent: "flex-end"
      } }, tetrad == null ? void 0 : tetrad.map((c, key) => import_react13.default.createElement("div", { key, style: { width: "25%", height: 28, background: c.toHexString() }, onClick: () => handleClick(c) })))
    )
  );
};
var ComparibleColors_default = ComparibleColors;

// node_modules/react-best-gradient-color-picker/dist/esm/components/GradientControls.js
var import_react14 = __toESM(require_react(), 1);
var GradientType = () => {
  const { gradientType, onChange, value, classes } = usePicker();
  const isLinear = gradientType === "linear-gradient";
  const isRadial = gradientType === "radial-gradient";
  const handleLinear = () => {
    const remaining = value.split(/,(.+)/)[1];
    onChange(`linear-gradient(90deg, ${remaining}`);
  };
  const handleRadial = () => {
    const remaining = value.split(/,(.+)/)[1];
    onChange(`radial-gradient(circle, ${remaining}`);
  };
  return import_react14.default.createElement(
    "div",
    { className: classes.rbgcpControlBtnWrapper },
    import_react14.default.createElement(
      "div",
      { onClick: handleLinear, id: "rbgcp-linear-btn", className: `${classes.rbgcpControlBtn} ${isLinear && classes.rbgcpControlBtnSelected}` },
      import_react14.default.createElement(LinearIcon, { color: isLinear ? "#568CF5" : "" })
    ),
    import_react14.default.createElement(
      "div",
      { onClick: handleRadial, id: "rbgcp-radial-btn", className: `${classes.rbgcpControlBtn} ${isRadial && classes.rbgcpControlBtnSelected}` },
      import_react14.default.createElement(RadialIcon, { color: isRadial ? "#568CF5" : "" })
    )
  );
};
var StopPicker = () => {
  const { classes, currentLeft, handleGradient, currentColor } = usePicker();
  const handleMove = (newVal) => {
    handleGradient(currentColor, formatInputValues(parseInt(newVal), 0, 100));
  };
  return import_react14.default.createElement(
    "div",
    { className: `${classes.rbgcpControlBtnWrapper} ${classes.rbgcpControlInputWrap} ${classes.rbgcpStopInputWrap}`, style: { paddingLeft: 8 } },
    import_react14.default.createElement(StopIcon, null),
    import_react14.default.createElement("input", { value: currentLeft, id: "rbgcp-stop-input", onChange: (e) => handleMove(e.target.value), className: `${classes.rbgcpControlInput} ${classes.rbgcpStopInput}` })
  );
};
var DegreePicker = () => {
  const { classes, degrees, onChange, value } = usePicker();
  const handleDegrees = (e) => {
    const newValue = formatInputValues(e.target.value, 0, 360);
    const remaining = value.split(/,(.+)/)[1];
    onChange(`linear-gradient(${newValue || 0}deg, ${remaining}`);
  };
  return import_react14.default.createElement(
    "div",
    { className: `${classes.rbgcpControlBtnWrapper} ${classes.rbgcpControlInputWrap} ${classes.rbgcpDegreeInputWrap}` },
    import_react14.default.createElement(DegreesIcon, null),
    import_react14.default.createElement("input", { value: degrees, id: "rbgcp-degree-input", onChange: (e) => handleDegrees(e), className: `${classes.rbgcpControlInput} ${classes.rbgcpDegreeInput}` }),
    import_react14.default.createElement("div", { style: {
      position: "absolute",
      right: degrees > 99 ? 0 : degrees < 10 ? 7 : 3,
      top: 1,
      fontWeight: 400,
      fontSize: 13
    }, className: classes.rbgcpDegreeIcon }, "")
  );
};
var DeleteBtn = () => {
  const { colors, classes, selectedColor, createGradientStr } = usePicker();
  const deletePoint = () => {
    if ((colors == null ? void 0 : colors.length) > 2) {
      const formatted = colors == null ? void 0 : colors.map((fc, i) => ({
        ...fc,
        value: i === selectedColor - 1 ? high(fc) : low(fc)
      }));
      const remaining = formatted == null ? void 0 : formatted.filter((_, i) => i !== selectedColor);
      createGradientStr(remaining);
    }
  };
  return import_react14.default.createElement(
    "div",
    { onClick: deletePoint, style: { width: 28 }, id: "rbgcp-point-delete-btn", className: controlBtnStyles(false, classes) },
    import_react14.default.createElement(icon_default, null)
  );
};
var GradientControls = ({ hideGradientType, hideGradientAngle, hideGradientStop }) => {
  const { gradientType, classes } = usePicker();
  return import_react14.default.createElement(
    "div",
    { style: {
      marginTop: 12,
      marginBottom: -4,
      justifyContent: "space-between",
      paddingLeft: hideGradientType ? 4 : 0
    }, id: "rbgcp-gradient-controls-wrap", className: classes.rbgcpControlBtnWrapper },
    !hideGradientType && import_react14.default.createElement(GradientType, null),
    import_react14.default.createElement("div", { style: { width: 53 } }, !hideGradientAngle && gradientType === "linear-gradient" && import_react14.default.createElement(DegreePicker, null)),
    !hideGradientStop && import_react14.default.createElement(StopPicker, null),
    import_react14.default.createElement(DeleteBtn, null)
  );
};
var GradientControls_default = GradientControls;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Controls.js
var { defaultColor: defaultColor2, defaultGradient: defaultGradient2 } = config;
var Controls = ({ locales, hideEyeDrop, hideAdvancedSliders, hideColorGuide, hideInputType, hideColorTypeBtns, hideGradientControls, hideGradientType, hideGradientAngle, hideGradientStop }) => {
  const { onChange, isGradient, handleChange, classes, previous } = usePicker();
  const [openComparibles, setOpenComparibles] = (0, import_react15.useState)(false);
  const [openInputType, setOpenInputType] = (0, import_react15.useState)(false);
  const [openAdvanced, setOpenAdvanced] = (0, import_react15.useState)(false);
  const noTools = hideEyeDrop && hideAdvancedSliders && hideColorGuide && hideInputType;
  const solidColor = (previous == null ? void 0 : previous.color) || defaultColor2;
  const gradientColor = (previous == null ? void 0 : previous.gradient) || defaultGradient2;
  const setSolid = () => {
    onChange(solidColor);
  };
  const setGradient = () => {
    onChange(gradientColor);
  };
  const allRightControlsHidden = hideEyeDrop && hideAdvancedSliders && hideColorGuide && hideInputType;
  const allControlsHidden = allRightControlsHidden && hideColorTypeBtns;
  if (allControlsHidden) {
    if (isGradient && !hideGradientControls) {
      return import_react15.default.createElement(GradientControls_default, { hideGradientType, hideGradientAngle, hideGradientStop });
    } else {
      return null;
    }
  } else {
    return import_react15.default.createElement(
      "div",
      { style: { paddingTop: 12, paddingBottom: 4 } },
      import_react15.default.createElement(
        "div",
        { style: { width: "100%" }, className: `${classes.ac} ${classes.jsb}` },
        import_react15.default.createElement(ColorTypeBtns, { hideColorTypeBtns, setGradient, isGradient, setSolid, locales }),
        !allRightControlsHidden && import_react15.default.createElement(
          "div",
          { style: { display: noTools ? "none" : "" }, className: classes.rbgcpControlBtnWrapper },
          !hideEyeDrop && import_react15.default.createElement(EyeDropper_default, { onSelect: handleChange }),
          import_react15.default.createElement(
            "div",
            { id: "rbgcp-advanced-btn", onClick: () => setOpenAdvanced(!openAdvanced), className: controlBtnStyles(openAdvanced, classes), style: { display: hideAdvancedSliders ? "none" : "flex" } },
            import_react15.default.createElement(SlidersIcon, { color: openAdvanced ? "#568CF5" : "" })
          ),
          import_react15.default.createElement(
            "div",
            { id: "rbgcp-comparibles-btn", style: { display: hideColorGuide ? "none" : "flex" }, onClick: () => setOpenComparibles(!openComparibles), className: controlBtnStyles(openComparibles, classes) },
            import_react15.default.createElement(PaletteIcon, { color: openComparibles ? "#568CF5" : "" })
          ),
          import_react15.default.createElement(
            "div",
            { id: "rbgcp-color-model-btn", onClick: () => setOpenInputType(!openInputType), className: controlBtnStyles(openInputType, classes), style: { display: hideInputType ? "none" : "flex" } },
            import_react15.default.createElement(InputsIcon, { color: openInputType ? "#568CF5" : "" }),
            import_react15.default.createElement(InputTypeDropdown, { openInputType, setOpenInputType })
          )
        )
      ),
      !hideAdvancedSliders && import_react15.default.createElement(AdvancedControls_default, { openAdvanced }),
      !hideColorGuide && import_react15.default.createElement(ComparibleColors_default, { openComparibles }),
      isGradient && !hideGradientControls && import_react15.default.createElement(GradientControls_default, { hideGradientType, hideGradientAngle, hideGradientStop })
    );
  }
};
var Controls_default = Controls;
var InputTypeDropdown = ({ openInputType, setOpenInputType }) => {
  const { inputType, setInputType, classes } = usePicker();
  const vTrans = openInputType ? "visibility 0ms linear" : "visibility 100ms linear 150ms";
  const zTrans = openInputType ? "z-index 0ms linear" : "z-index 100ms linear 150ms";
  const oTrans = openInputType ? "opacity 120ms linear" : "opacity 150ms linear 50ms";
  const handleInputType = (e, val) => {
    if (openInputType) {
      e.stopPropagation();
      setInputType(val);
      setOpenInputType(false);
    }
  };
  return import_react15.default.createElement(
    "div",
    { style: {
      visibility: openInputType ? "visible" : "hidden",
      zIndex: openInputType ? "" : -100,
      opacity: openInputType ? 1 : 0,
      transition: `${oTrans}, ${vTrans}, ${zTrans}`
    }, className: classes.rbgcpColorModelDropdown },
    import_react15.default.createElement("div", { onClick: (e) => handleInputType(e, "rgb"), className: modalBtnStyles(inputType === "rgb", classes) }, "RGB"),
    import_react15.default.createElement("div", { onClick: (e) => handleInputType(e, "hsl"), className: modalBtnStyles(inputType === "hsl", classes) }, "HSL"),
    import_react15.default.createElement("div", { onClick: (e) => handleInputType(e, "hsv"), className: modalBtnStyles(inputType === "hsv", classes) }, "HSV"),
    import_react15.default.createElement("div", { onClick: (e) => handleInputType(e, "cmyk"), className: modalBtnStyles(inputType === "cmyk", classes) }, "CMYK")
  );
};
var ColorTypeBtns = ({ hideColorTypeBtns, isGradient, setSolid, setGradient, locales }) => {
  var _a, _b;
  const { classes } = usePicker();
  if (hideColorTypeBtns) {
    return import_react15.default.createElement("div", { style: { width: 1 } });
  } else {
    return import_react15.default.createElement(
      "div",
      { className: classes.rbgcpControlBtnWrapper },
      import_react15.default.createElement("div", { onClick: setSolid, id: "rbgcp-solid-btn", className: colorTypeBtnStyles(!isGradient, classes) }, (_a = locales == null ? void 0 : locales.CONTROLS) == null ? void 0 : _a.SOLID),
      import_react15.default.createElement("div", { onClick: setGradient, id: "rbgcp-gradient-btn", className: colorTypeBtnStyles(isGradient || false, classes) }, (_b = locales == null ? void 0 : locales.CONTROLS) == null ? void 0 : _b.GRADIENT)
    );
  }
};
var colorTypeBtnStyles = (selected, classes) => {
  if (selected) {
    return `${classes.rbgcpControlBtn} ${classes.rbgcpControlBtnSelected}`;
  } else {
    return classes.rbgcpControlBtn;
  }
};
var controlBtnStyles = (selected, classes) => {
  if (selected) {
    return `${classes.rbgcpControlIconBtn} ${classes.rbgcpControlBtnSelected}`;
  } else {
    return classes.rbgcpControlIconBtn;
  }
};
var modalBtnStyles = (selected, classes) => {
  if (selected) {
    return `${classes.rbgcpControlBtn} ${classes.rbgcpColorModelDropdownBtn} ${classes.rbgcpControlBtnSelected}`;
  } else {
    return `${classes.rbgcpControlBtn} ${classes.rbgcpColorModelDropdownBtn}`;
  }
};

// node_modules/react-best-gradient-color-picker/dist/esm/components/GradientBar.js
var import_react16 = __toESM(require_react(), 1);
var handleStyle = (isSelected) => {
  return {
    boxShadow: isSelected ? "0px 0px 5px 1px rgba(86, 140, 245,.95)" : "",
    border: isSelected ? "2px solid white" : "2px solid rgba(255,255,255,.75)"
  };
};
var Handle = ({ left, i, setDragging, setInFocus }) => {
  const { colors, selectedColor, squareWidth, classes, createGradientStr } = usePicker();
  const isSelected = selectedColor === i;
  const leftMultiplyer = (squareWidth - 18) / 100;
  const setSelectedColor = (index) => {
    const newGradStr = colors == null ? void 0 : colors.map((cc, i2) => ({
      ...cc,
      value: i2 === index ? high(cc) : low(cc)
    }));
    createGradientStr(newGradStr);
  };
  const handleDown = (e) => {
    e.stopPropagation();
    setSelectedColor(i);
    setDragging(true);
  };
  const handleFocus = () => {
    setSelectedColor(i);
  };
  const handleBlur = () => {
  };
  return import_react16.default.createElement(
    "div",
    { tabIndex: 0, onBlur: handleBlur, onFocus: handleFocus, id: `gradient-handle-${i}`, onMouseDown: (e) => handleDown(e), className: classes.rbgcpGradientHandleWrap, style: { left: (left || 0) * leftMultiplyer } },
    import_react16.default.createElement("div", { style: handleStyle(isSelected), className: classes.rbgcpGradientHandle }, isSelected && import_react16.default.createElement("div", { style: {
      width: 5,
      height: 5,
      borderRadius: "50%",
      background: "white"
    } }))
  );
};
var GradientBar = () => {
  const { currentColor, createGradientStr, colors, value, handleGradient, squareWidth, deletePoint, isGradient, selectedColor } = usePicker();
  const [dragging, setDragging] = (0, import_react16.useState)(false);
  const [inFocus, setInFocus] = (0, import_react16.useState)(null);
  function force90degLinear(color) {
    return color.replace(/(radial|linear)-gradient\([^,]+,/, "linear-gradient(90deg,");
  }
  const addPoint = (e) => {
    var _a;
    const left = getHandleValue(e);
    const newColors = (_a = [
      ...colors.map((c) => ({ ...c, value: low(c) })),
      { value: currentColor, left }
    ]) == null ? void 0 : _a.sort((a, b) => a.left - b.left);
    createGradientStr(newColors);
  };
  (0, import_react16.useEffect)(() => {
    var _a;
    const selectedEl = (_a = window == null ? void 0 : window.document) == null ? void 0 : _a.getElementById(`gradient-handle-${selectedColor}`);
    if (selectedEl) {
      selectedEl.focus();
    }
  }, [selectedColor]);
  const stopDragging = () => {
    setDragging(false);
  };
  const handleDown = (e) => {
    if (!dragging) {
      addPoint(e);
      setDragging(true);
    }
  };
  const handleMove = (e) => {
    if (dragging) {
      handleGradient(currentColor, getHandleValue(e));
    }
  };
  const handleKeyboard = (e) => {
    if (isGradient) {
      if (e.keyCode === 8) {
        if (inFocus === "gpoint") {
          deletePoint();
        }
      }
    }
  };
  const handleUp = () => {
    stopDragging();
  };
  (0, import_react16.useEffect)(() => {
    window.addEventListener("mouseup", handleUp);
    window == null ? void 0 : window.addEventListener("keydown", handleKeyboard);
    return () => {
      window.removeEventListener("mouseup", handleUp);
      window == null ? void 0 : window.removeEventListener("keydown", handleKeyboard);
    };
  });
  return import_react16.default.createElement(
    "div",
    { style: {
      width: "100%",
      marginTop: 17,
      marginBottom: 4,
      position: "relative"
    }, id: "gradient-bar" },
    import_react16.default.createElement("div", { style: {
      width: squareWidth,
      height: 14,
      backgroundImage: force90degLinear(value),
      borderRadius: 10
    }, onMouseDown: (e) => handleDown(e), onMouseMove: (e) => handleMove(e) }),
    colors == null ? void 0 : colors.map((c, i) => import_react16.default.createElement(Handle, { i, left: c.left, key: `${i}-${c}`, setInFocus, setDragging }))
  );
};
var GradientBar_default = GradientBar;

// node_modules/react-best-gradient-color-picker/dist/esm/components/Picker.js
var Picker = ({ locales, presets, hideHue, hideInputs, hidePresets, hideOpacity, hideEyeDrop, hideControls, hideInputType, hideColorGuide, hideGradientType, hideGradientStop, hideGradientAngle, hideColorTypeBtns, hideAdvancedSliders, hideGradientControls }) => {
  const { isGradient } = usePicker();
  return import_react17.default.createElement(
    "div",
    { style: { userSelect: "none" }, id: "rbgcp-wrapper" },
    import_react17.default.createElement(Square_default, null),
    !hideControls && import_react17.default.createElement(Controls_default, { locales, hideEyeDrop, hideInputType, hideColorGuide, hideGradientType, hideGradientStop, hideColorTypeBtns, hideGradientAngle, hideAdvancedSliders, hideGradientControls }),
    isGradient && import_react17.default.createElement(GradientBar_default, null),
    !hideHue && import_react17.default.createElement(Hue_default, null),
    !hideOpacity && import_react17.default.createElement(Opacity_default, null),
    !hideInputs && import_react17.default.createElement(Inputs_default, null),
    !hidePresets && import_react17.default.createElement(Presets_default, { presets })
  );
};
var Picker_default = Picker;

// node_modules/react-best-gradient-color-picker/dist/esm/components/index.js
import coreCss from "C:/Users/SCUM/Documents/Repos/Spring Backend Projects/shadcn-reactjs-starter-main/node_modules/react-best-gradient-color-picker/dist/esm/core.module.css";
function ColorPicker({ value = "rgba(175, 51, 242, 1)", onChange, hideControls = false, hideInputs = false, hideOpacity = false, hidePresets = false, hideHue = false, presets = [], hideEyeDrop = false, hideAdvancedSliders = false, hideColorGuide = false, hideInputType = false, hideColorTypeBtns = false, hideGradientType = false, hideGradientAngle = false, hideGradientStop = false, hideGradientControls = false, locales = defaultLocales, width = 294, height = 294, style = {}, className }) {
  const safeValue = objectToString(value);
  const contRef = (0, import_react18.useRef)(null);
  return import_react18.default.createElement(
    "div",
    { ref: contRef, className, style: { ...style, width } },
    import_react18.default.createElement(
      PickerContextWrapper,
      { value: safeValue, classes: coreCss, onChange, squareWidth: width, squareHeight: height, hideOpacity },
      import_react18.default.createElement(Picker_default, { hideControls, hideInputs, hidePresets, hideOpacity, hideHue, presets, hideEyeDrop, hideAdvancedSliders, hideColorGuide, hideInputType, hideColorTypeBtns, hideGradientType, hideGradientAngle, hideGradientStop, hideGradientControls, locales })
    )
  );
}

// node_modules/react-best-gradient-color-picker/dist/esm/hooks/useColorPicker.js
var import_react19 = __toESM(require_react(), 1);
var import_tinycolor29 = __toESM(require_tinycolor(), 1);
var { defaultColor: defaultColor3, defaultGradient: defaultGradient3 } = config;
var useColorPicker = (value, onChange) => {
  const colors = getColors(value);
  const { degrees, degreeStr, isGradient, gradientType } = getDetails(value);
  const { currentColor, selectedColor, currentLeft } = getColorObj(colors);
  const [previousColors, setPreviousColors] = (0, import_react19.useState)([]);
  const getGradientObject = () => {
    if (value) {
      if (isGradient) {
        return {
          isGradient: true,
          gradientType,
          degrees: degreeStr,
          colors: colors == null ? void 0 : colors.map((c) => {
            var _a;
            return {
              ...c,
              value: (_a = c.value) == null ? void 0 : _a.toLowerCase()
            };
          })
        };
      } else {
        return {
          isGradient: false,
          gradientType: null,
          degrees: null,
          colors: colors == null ? void 0 : colors.map((c) => {
            var _a;
            return {
              ...c,
              value: (_a = c.value) == null ? void 0 : _a.toLowerCase()
            };
          })
        };
      }
    } else {
      console.log("RBGCP ERROR - YOU MUST PASS A VALUE AND CALLBACK TO THE useColorPicker HOOK");
    }
  };
  const tiny = (0, import_tinycolor29.default)(currentColor);
  const { r, g, b, a } = tiny.toRgb();
  const { h, s, l } = tiny.toHsl();
  (0, import_react19.useEffect)(() => {
    var _a;
    if (((_a = (0, import_tinycolor29.default)(currentColor)) == null ? void 0 : _a.isValid()) && previousColors[0] !== currentColor) {
      setPreviousColors([currentColor, ...previousColors.slice(0, 19)]);
    }
  }, [currentColor, previousColors]);
  const setLinear = () => {
    const remaining = value.split(/,(.+)/)[1];
    onChange(`linear-gradient(90deg, ${remaining}`);
  };
  const setRadial = () => {
    const remaining = value.split(/,(.+)/)[1];
    onChange(`radial-gradient(circle, ${remaining}`);
  };
  const setDegrees = (newDegrees) => {
    const remaining = value.split(/,(.+)/)[1];
    onChange(`linear-gradient(${formatInputValues(newDegrees, 0, 360)}deg, ${remaining}`);
    if (gradientType !== "linear-gradient") {
      console.log("Warning: you are updating degrees when the gradient type is not linear. This will change the gradients type which may be undesired");
    }
  };
  const setSolid = (startingColor) => {
    const newValue = startingColor || defaultColor3;
    onChange(newValue);
  };
  const setGradient = (startingGradiant) => {
    const newValue = startingGradiant || defaultGradient3;
    onChange(newValue);
  };
  const createGradientStr = (newColors) => {
    const sorted = newColors.sort((a2, b2) => a2.left - b2.left);
    const colorString = sorted == null ? void 0 : sorted.map((cc) => `${cc == null ? void 0 : cc.value} ${cc.left}%`);
    onChange(`${gradientType}(${degreeStr}, ${colorString.join(", ")})`);
  };
  const handleGradient = (newColor, left) => {
    const remaining = colors == null ? void 0 : colors.filter((c) => !isUpperCase(c.value));
    const newColors = [
      { value: newColor.toUpperCase(), left: left || currentLeft },
      ...remaining
    ];
    createGradientStr(newColors);
  };
  const handleChange = (newColor) => {
    if (isGradient) {
      handleGradient(newColor);
    } else {
      onChange(newColor);
    }
  };
  const setR = (newR) => {
    const newVal = formatInputValues(newR, 0, 255);
    handleChange(`rgba(${newVal}, ${g}, ${b}, ${a})`);
  };
  const setG = (newG) => {
    const newVal = formatInputValues(newG, 0, 255);
    handleChange(`rgba(${r}, ${newVal}, ${b}, ${a})`);
  };
  const setB = (newB) => {
    const newVal = formatInputValues(newB, 0, 255);
    handleChange(`rgba(${r}, ${g}, ${newVal}, ${a})`);
  };
  const setA = (newA) => {
    const newVal = formatInputValues(newA, 0, 100);
    handleChange(`rgba(${r}, ${g}, ${b}, ${newVal / 100})`);
  };
  const setHue = (newHue) => {
    const newVal = formatInputValues(newHue, 0, 360);
    const tinyNew = (0, import_tinycolor29.default)({ h: newVal, s, l });
    const { r: r2, g: g2, b: b2 } = tinyNew.toRgb();
    handleChange(`rgba(${r2}, ${g2}, ${b2}, ${a})`);
  };
  const setSaturation = (newSat) => {
    const newVal = formatInputValues(newSat, 0, 100);
    const tinyNew = (0, import_tinycolor29.default)({ h, s: newVal / 100, l });
    const { r: r2, g: g2, b: b2 } = tinyNew.toRgb();
    handleChange(`rgba(${r2}, ${g2}, ${b2}, ${a})`);
  };
  const setLightness = (newLight) => {
    const newVal = formatInputValues(newLight, 0, 100);
    const tinyNew = (0, import_tinycolor29.default)({ h, s, l: newVal / 100 });
    if (tinyNew == null ? void 0 : tinyNew.isValid()) {
      const { r: r2, g: g2, b: b2 } = tinyNew.toRgb();
      handleChange(`rgba(${r2}, ${g2}, ${b2}, ${a})`);
    } else {
      console.log("The new color was invalid, perhaps the lightness you passed in was a decimal? Please pass the new value between 0 - 100");
    }
  };
  const valueToHSL = () => {
    return tiny.toHslString();
  };
  const valueToHSV = () => {
    return tiny.toHsvString();
  };
  const valueToHex = () => {
    return tiny.toHexString();
  };
  const valueToCmyk = () => {
    const { c, m, y, k } = rgb2cmyk(r, g, b);
    return `cmyk(${c}, ${m}, ${y}, ${k})`;
  };
  const setSelectedPoint = (index) => {
    if (isGradient) {
      const newGradStr = colors == null ? void 0 : colors.map((cc, i) => ({
        ...cc,
        value: i === index ? high(cc) : low(cc)
      }));
      createGradientStr(newGradStr);
    } else {
      console.log("This function is only relevant when the picker is in gradient mode");
    }
  };
  const addPoint = (left) => {
    const newColors = [
      ...colors.map((c) => ({ ...c, value: low(c) })),
      { value: currentColor, left }
    ];
    createGradientStr(newColors);
    if (!left) {
      console.log("You did not pass a stop value (left amount) for the new color point so it defaulted to 50");
    }
  };
  const deletePoint = (index) => {
    if ((colors == null ? void 0 : colors.length) > 2) {
      const pointToDelete = index || selectedColor;
      const remaining = colors == null ? void 0 : colors.filter((rc, i) => i !== pointToDelete);
      createGradientStr(remaining);
      if (!index) {
        console.log("You did not pass in the index of the point you wanted to delete so the function default to the currently selected point");
      }
    } else {
      console.log("A gradient must have atleast two colors, disable your delete button when necessary");
    }
  };
  const setPointLeft = (left) => {
    handleGradient(currentColor, formatInputValues(left, 0, 100));
  };
  const rgbaArr = [r, g, b, a];
  const hslArr = [h, s, l];
  return {
    setR,
    setG,
    setB,
    setA,
    setHue,
    addPoint,
    setSolid,
    setLinear,
    setRadial,
    valueToHSL,
    valueToHSV,
    valueToHex,
    valueToCmyk,
    setDegrees,
    setGradient,
    setLightness,
    setSaturation,
    setSelectedPoint,
    deletePoint,
    isGradient,
    gradientType,
    degrees,
    setPointLeft,
    currentLeft,
    rgbaArr,
    hslArr,
    handleChange,
    previousColors,
    getGradientObject,
    selectedPoint: selectedColor
  };
};

// node_modules/react-best-gradient-color-picker/dist/esm/index.js
var esm_default = ColorPicker;
export {
  esm_default as default,
  useColorPicker
};
//# sourceMappingURL=react-best-gradient-color-picker.js.map
